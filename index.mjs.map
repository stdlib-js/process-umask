{"version":3,"file":"index.mjs","sources":["../lib/to_symbolic.js","../lib/from_symbolic.js","../lib/browser.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport lpad from '@stdlib/string-left-pad';\nimport OCTAL_CODES from './octal_codes.json';\n\n\n// MAIN //\n\n/**\n* Converts an integer mask to symbolic notation.\n*\n* @private\n* @param {NonNegativeInteger} mask - integer mask\n* @returns {string} mask in symbolic notation\n*/\nfunction toSymbolic( mask ) {\n\tvar out;\n\n\t// Convert the mask to a four-digit octal string representation (e.g., 0077):\n\tmask = mask.toString( 8 );\n\tmask = lpad( mask, 4, '0' );\n\n\t// For each digit, get the permissions: (NOTE: we skip the special modes digit, as only the file permission bits of the mask are used; see http://man7.org/linux/man-pages/man2/umask.2.html)\n\tout = '';\n\tout += 'u='+OCTAL_CODES[ mask[1] ];\n\tout += ',';\n\tout += 'g='+OCTAL_CODES[ mask[2] ];\n\tout += ',';\n\tout += 'o='+OCTAL_CODES[ mask[3] ];\n\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default toSymbolic;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport lpad from '@stdlib/string-left-pad';\n\n\n// VARIABLES //\n\n// Regular expression to parse a mask expression:\nvar RE_MASK_EXPRESSION = /^(u{0,1}g{0,1}o{0,1}a{0,1}|)([+\\-=])(r{0,1}w{0,1}x{0,1})$/;\n\n// Table of permission bit mask offsets:\nvar PERMS = {\n\t'r': 2, // read\n\t'w': 1, // write\n\t'x': 0  // execute\n};\n\n// Table of class indices in the octal format (e.g., `0o0077`):\nvar WHO = {\n\t's': 0, // special mode (ignored; see http://man7.org/linux/man-pages/man2/umask.2.html)\n\t'u': 1, // user\n\t'g': 2, // group\n\t'o': 3  // other/non-group\n};\n\n\n// FUNCTIONS //\n\n/**\n* Returns a bit mask.\n*\n* @private\n* @param {NonNegativeInteger} offset - bit offset (right-to-left)\n* @returns {NonNegativeInteger} bit mask\n*\n* @example\n* var y = bitMask( 3 );\n* // returns 8\n*/\nfunction bitMask( offset ) {\n\treturn ( 1 << offset )>>>0; // asm type annotation\n}\n\n/**\n* Sets a bit.\n*\n* @private\n* @param {NonNegativeInteger} value - value\n* @param {NonNegativeInteger} offset - bit offset (right-to-left)\n* @returns {NonNegativeInteger} updated value\n*\n* @example\n* var y = setBit( 8, 2 );\n*/\nfunction setBit( value, offset ) {\n\treturn ( value | bitMask( offset ) )>>>0; // asm type annotation\n}\n\n/**\n* Clears a bit.\n*\n* @private\n* @param {NonNegativeInteger} value - value\n* @param {NonNegativeInteger} offset - bit offset (right-to-left)\n* @returns {NonNegativeInteger} updated value\n*/\nfunction clearBit( value, offset ) {\n\treturn ( value & ~bitMask( offset ) )>>>0; // asm type annotation\n}\n\n\n// MAIN //\n\n/**\n* Converts a mask expression in symbolic notation to an integer.\n*\n* @private\n* @param {NonNegativeInteger} mask - current mask\n* @param {string} expr - mask expression\n* @returns {(NonNegativeInteger|Error)} integer mask or parse error\n*/\nfunction fromSymbolic( mask, expr ) {\n\tvar digits;\n\tvar parts;\n\tvar perm;\n\tvar who;\n\tvar tmp;\n\tvar idx;\n\tvar op;\n\tvar w;\n\tvar o;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\t// Split the mask into octal digits (e.g., [ '0', '0', '7', '7' ]):\n\tdigits = lpad( mask.toString( 8 ), 4, '0' ).split( '' );\n\n\t// Convert each octal digit to an integer value:\n\tfor ( i = 0; i < digits.length; i++ ) {\n\t\tdigits[ i ] = parseInt( digits[ i ], 10 );\n\t}\n\n\t// See if we can easily split the mask into separate mask expressions (e.g., `u+x,g=rw,o=` => [ 'u+x', 'g=rw', 'o=' ] ):\n\tparts = expr.split( ',' );\n\n\t// For each expression, split into \"class\", \"operator\", and \"symbols\" and update the mask octal digits:\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\ttmp = parts[ i ].match( RE_MASK_EXPRESSION );\n\t\tif ( tmp === null ) {\n\t\t\treturn new Error( format( '0Om7C', expr ) );\n\t\t}\n\t\t// Extract the expression parts:\n\t\twho = tmp[ 1 ];\n\t\tif ( who === '' ) {\n\t\t\t// If a user class is not specified (e.g., `+x`), \"ugo\" (user, group, other) is implied...\n\t\t\twho = 'ugo';\n\t\t} else {\n\t\t\t// Replace `a` (all) user class letter with \"ugo\" (user, group, other) equivalent...\n\t\t\tw = '';\n\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\tif ( who[ k ] === 'a' ) {\n\t\t\t\t\tw += 'ugo';\n\t\t\t\t} else {\n\t\t\t\t\tw += who[ k ];\n\t\t\t\t}\n\t\t\t}\n\t\t\twho = w;\n\t\t}\n\t\top = tmp[ 2 ];\n\t\tperm = tmp[ 3 ];\n\n\t\t// NOTE: the algorithm below is from the perspective of the mask. If implemented for, say, `chmod`, the \"disabling\"/\"enabling\" logic would be reversed. Recall that a \"1\" in the mask, serves to **disable** a permission setting, not enable.\n\n\t\t// Disable permissions...\n\t\tif ( op === '-' ) {\n\t\t\tif ( perm === '' ) {\n\t\t\t\t// The `-` operation by itself does not change any bits...\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor ( j = 0; j < perm.length; j++ ) {\n\t\t\t\to = PERMS[ perm[j] ];\n\t\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\t\tdigits[ idx ] = setBit( digits[ idx ], o ); // to disable, we flip on mask bits\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Enable permissions...\n\t\telse if ( op === '+' ) {\n\t\t\tif ( perm === '' ) {\n\t\t\t\t// The `+` operation by itself does not change any bits...\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor ( j = 0; j < perm.length; j++ ) {\n\t\t\t\to = PERMS[ perm[j] ];\n\t\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\t\tdigits[ idx ] = clearBit( digits[ idx ], o ); // to enable, we clear mask bits\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Disable all permissions by flipping on all permission mask bits...\n\t\telse if ( perm === '' ) { // op === '='\n\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\tdigits[ idx ] = 7;\n\t\t\t}\n\t\t}\n\t\t// Explicitly set permissions...\n\t\telse { // op === '='\n\t\t\t// First, disable all permissions by flipping on all permission mask bits...\n\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\tdigits[ idx ] = 7;\n\t\t\t}\n\t\t\t// Then, explicitly enable permissions by clearing mask bits...\n\t\t\tfor ( j = 0; j < perm.length; j++ ) {\n\t\t\t\to = PERMS[ perm[j] ];\n\t\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\t\tdigits[ idx ] = clearBit( digits[ idx ], o );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Convert the digits to an integer value...\n\tfor ( i = 0; i < digits.length; i++ ) {\n\t\tdigits[ i ] = digits[ i ].toString();\n\t}\n\treturn parseInt( digits.join( '' ), 8 );\n}\n\n\n// EXPORTS //\n\nexport default fromSymbolic;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isString } from '@stdlib/assert-is-string';\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport toSymbolic from './to_symbolic.js';\nimport fromSymbolic from './from_symbolic.js';\n\n\n// VARIABLES //\n\nvar MASK = 0|0; // asm type annotation\n\n\n// MAIN //\n\n/**\n* Get/set the process mask.\n*\n* ## Notes\n*\n* -   If provided a mask, the function sets the current mask and returns the previous process mask. Otherwise, the function returns the current process mask.\n* -   Browser environments do not support process masks. Hence, this function always returns either `0` or `u=rwx,g=rwx,o=rwx`.\n*\n* @param {(NonNegativeInteger|string)} [mask] - mask\n* @param {Object} [options] - options\n* @param {boolean} [options.symbolic] - boolean indicating whether to return a mask using symbolic notation\n* @throws {TypeError} must provide either a string, nonnegative integer, or an options object\n* @throws {TypeError} must provide valid options\n* @throws {Error} must provide a parseable expression mask\n* @returns {(NonNegativeInteger|string)} process mask\n*\n* @example\n* var mask = umask();\n* // returns 0\n*/\nfunction umask() {\n\tvar options;\n\tvar nargs;\n\tvar mask;\n\tvar opts;\n\tvar arg;\n\n\tnargs = arguments.length;\n\tif ( nargs === 0 ) {\n\t\treturn MASK;\n\t}\n\topts = {};\n\targ = arguments[ 0 ];\n\tif ( nargs === 1 ) {\n\t\tif ( isString( arg ) ) {\n\t\t\tmask = fromSymbolic( MASK, arg );\n\t\t\tif ( mask instanceof Error ) {\n\t\t\t\tthrow mask;\n\t\t\t}\n\t\t\treturn MASK;\n\t\t}\n\t\tif ( isNonNegativeInteger( arg ) ) {\n\t\t\t// Easy case where we use the built-in function to set the mask and return its return value:\n\t\t\treturn MASK;\n\t\t}\n\t\tif ( isObject( arg ) ) {\n\t\t\tif ( hasOwnProp( arg, 'symbolic' ) ) {\n\t\t\t\topts.symbolic = arg.symbolic;\n\t\t\t\tif ( !isBoolean( opts.symbolic ) ) {\n\t\t\t\t\tthrow new TypeError( format( '0Om30', 'symbolic', opts.symbolic ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask = MASK;\n\t\t\tif ( opts.symbolic ) {\n\t\t\t\tmask = toSymbolic( mask );\n\t\t\t}\n\t\t\treturn mask;\n\t\t}\n\t\tthrow new TypeError( format( '0Om7A', arg ) );\n\t}\n\toptions = arguments[ 1 ];\n\tif ( !isObject( options ) ) {\n\t\tthrow new TypeError( format( '0Om2h', options ) );\n\t}\n\tif ( hasOwnProp( options, 'symbolic' ) ) {\n\t\topts.symbolic = options.symbolic;\n\t\tif ( !isBoolean( opts.symbolic ) ) {\n\t\t\tthrow new TypeError( format( '0Om30', 'symbolic', opts.symbolic ) );\n\t\t}\n\t}\n\tif ( isString( arg ) ) {\n\t\tmask = fromSymbolic( MASK, arg );\n\t\tif ( mask instanceof Error ) {\n\t\t\tthrow mask;\n\t\t}\n\t} else if ( isNonNegativeInteger( arg ) ) {\n\t\tmask = arg;\n\t} else {\n\t\tthrow new TypeError( format( '0Om7B', arg ) );\n\t}\n\t// Set the mask:\n\tmask = MASK;\n\n\t// Determine how to format the output value:\n\tif ( opts.symbolic ) {\n\t\tmask = toSymbolic( mask );\n\t}\n\treturn mask;\n}\n\n\n// EXPORTS //\n\nexport default umask;\n"],"names":["toSymbolic","mask","out","toString","lpad","OCTAL_CODES","RE_MASK_EXPRESSION","PERMS","r","w","x","WHO","s","u","g","o","bitMask","offset","clearBit","value","fromSymbolic","expr","digits","parts","perm","who","tmp","idx","op","i","j","k","split","length","parseInt","match","Error","format","join","umask","options","nargs","opts","arg","arguments","isString","isNonNegativeInteger","isObject","hasOwnProp","symbolic","isBoolean","TypeError"],"mappings":"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"}