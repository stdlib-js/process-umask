{"version":3,"file":"index.mjs","sources":["../lib/to_symbolic.js","../lib/from_symbolic.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar lpad = require( '@stdlib/string-left-pad' );\nvar OCTAL_CODES = require( './octal_codes.json' );\n\n\n// MAIN //\n\n/**\n* Converts an integer mask to symbolic notation.\n*\n* @private\n* @param {NonNegativeInteger} mask - integer mask\n* @returns {string} mask in symbolic notation\n*/\nfunction toSymbolic( mask ) {\n\tvar out;\n\n\t// Convert the mask to a four-digit octal string representation (e.g., 0077):\n\tmask = mask.toString( 8 );\n\tmask = lpad( mask, 4, '0' );\n\n\t// For each digit, get the permissions: (NOTE: we skip the special modes digit, as only the file permission bits of the mask are used; see http://man7.org/linux/man-pages/man2/umask.2.html)\n\tout = '';\n\tout += 'u='+OCTAL_CODES[ mask[1] ];\n\tout += ',';\n\tout += 'g='+OCTAL_CODES[ mask[2] ];\n\tout += ',';\n\tout += 'o='+OCTAL_CODES[ mask[3] ];\n\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = toSymbolic;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar format = require( '@stdlib/string-format' );\nvar lpad = require( '@stdlib/string-left-pad' );\n\n\n// VARIABLES //\n\n// Regular expression to parse a mask expression:\nvar RE_MASK_EXPRESSION = /^(u{0,1}g{0,1}o{0,1}a{0,1}|)([+\\-=])(r{0,1}w{0,1}x{0,1})$/;\n\n// Table of permission bit mask offsets:\nvar PERMS = {\n\t'r': 2, // read\n\t'w': 1, // write\n\t'x': 0  // execute\n};\n\n// Table of class indices in the octal format (e.g., `0o0077`):\nvar WHO = {\n\t's': 0, // special mode (ignored; see http://man7.org/linux/man-pages/man2/umask.2.html)\n\t'u': 1, // user\n\t'g': 2, // group\n\t'o': 3  // other/non-group\n};\n\n\n// FUNCTIONS //\n\n/**\n* Returns a bit mask.\n*\n* @private\n* @param {NonNegativeInteger} offset - bit offset (right-to-left)\n* @returns {NonNegativeInteger} bit mask\n*\n* @example\n* var y = bitMask( 3 );\n* // returns 8\n*/\nfunction bitMask( offset ) {\n\treturn ( 1 << offset )>>>0; // asm type annotation\n}\n\n/**\n* Sets a bit.\n*\n* @private\n* @param {NonNegativeInteger} value - value\n* @param {NonNegativeInteger} offset - bit offset (right-to-left)\n* @returns {NonNegativeInteger} updated value\n*\n* @example\n* var y = setBit( 8, 2 );\n*/\nfunction setBit( value, offset ) {\n\treturn ( value | bitMask( offset ) )>>>0; // asm type annotation\n}\n\n/**\n* Clears a bit.\n*\n* @private\n* @param {NonNegativeInteger} value - value\n* @param {NonNegativeInteger} offset - bit offset (right-to-left)\n* @returns {NonNegativeInteger} updated value\n*/\nfunction clearBit( value, offset ) {\n\treturn ( value & ~bitMask( offset ) )>>>0; // asm type annotation\n}\n\n\n// MAIN //\n\n/**\n* Converts a mask expression in symbolic notation to an integer.\n*\n* @private\n* @param {NonNegativeInteger} mask - current mask\n* @param {string} expr - mask expression\n* @returns {(NonNegativeInteger|Error)} integer mask or parse error\n*/\nfunction fromSymbolic( mask, expr ) {\n\tvar digits;\n\tvar parts;\n\tvar perm;\n\tvar who;\n\tvar tmp;\n\tvar idx;\n\tvar op;\n\tvar w;\n\tvar o;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\t// Split the mask into octal digits (e.g., [ '0', '0', '7', '7' ]):\n\tdigits = lpad( mask.toString( 8 ), 4, '0' ).split( '' );\n\n\t// Convert each octal digit to an integer value:\n\tfor ( i = 0; i < digits.length; i++ ) {\n\t\tdigits[ i ] = parseInt( digits[ i ], 10 );\n\t}\n\n\t// See if we can easily split the mask into separate mask expressions (e.g., `u+x,g=rw,o=` => [ 'u+x', 'g=rw', 'o=' ] ):\n\tparts = expr.split( ',' );\n\n\t// For each expression, split into \"class\", \"operator\", and \"symbols\" and update the mask octal digits:\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\ttmp = parts[ i ].match( RE_MASK_EXPRESSION );\n\t\tif ( tmp === null ) {\n\t\t\treturn new Error( format( 'invalid argument. Unable to parse mask expression. Ensure the expression is properly formatted, only uses the class letters \"u\", \"g\", \"o\", and \"a\", only uses the operators \"+\", \"-\", and \"=\", and only uses the permission symbols \"r\", \"w\", and \"x\". Value: `%s`.', expr ) );\n\t\t}\n\t\t// Extract the expression parts:\n\t\twho = tmp[ 1 ];\n\t\tif ( who === '' ) {\n\t\t\t// If a user class is not specified (e.g., `+x`), \"ugo\" (user, group, other) is implied...\n\t\t\twho = 'ugo';\n\t\t} else {\n\t\t\t// Replace `a` (all) user class letter with \"ugo\" (user, group, other) equivalent...\n\t\t\tw = '';\n\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\tif ( who[ k ] === 'a' ) {\n\t\t\t\t\tw += 'ugo';\n\t\t\t\t} else {\n\t\t\t\t\tw += who[ k ];\n\t\t\t\t}\n\t\t\t}\n\t\t\twho = w;\n\t\t}\n\t\top = tmp[ 2 ];\n\t\tperm = tmp[ 3 ];\n\n\t\t// NOTE: the algorithm below is from the perspective of the mask. If implemented for, say, `chmod`, the \"disabling\"/\"enabling\" logic would be reversed. Recall that a \"1\" in the mask, serves to **disable** a permission setting, not enable.\n\n\t\t// Disable permissions...\n\t\tif ( op === '-' ) {\n\t\t\tif ( perm === '' ) {\n\t\t\t\t// The `-` operation by itself does not change any bits...\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor ( j = 0; j < perm.length; j++ ) {\n\t\t\t\to = PERMS[ perm[j] ];\n\t\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\t\tdigits[ idx ] = setBit( digits[ idx ], o ); // to disable, we flip on mask bits\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Enable permissions...\n\t\telse if ( op === '+' ) {\n\t\t\tif ( perm === '' ) {\n\t\t\t\t// The `+` operation by itself does not change any bits...\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor ( j = 0; j < perm.length; j++ ) {\n\t\t\t\to = PERMS[ perm[j] ];\n\t\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\t\tdigits[ idx ] = clearBit( digits[ idx ], o ); // to enable, we clear mask bits\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Disable all permissions by flipping on all permission mask bits...\n\t\telse if ( perm === '' ) { // op === '='\n\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\tdigits[ idx ] = 7;\n\t\t\t}\n\t\t}\n\t\t// Explicitly set permissions...\n\t\telse { // op === '='\n\t\t\t// First, disable all permissions by flipping on all permission mask bits...\n\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\tdigits[ idx ] = 7;\n\t\t\t}\n\t\t\t// Then, explicitly enable permissions by clearing mask bits...\n\t\t\tfor ( j = 0; j < perm.length; j++ ) {\n\t\t\t\to = PERMS[ perm[j] ];\n\t\t\t\tfor ( k = 0; k < who.length; k++ ) {\n\t\t\t\t\tidx = WHO[ who[k] ];\n\t\t\t\t\tdigits[ idx ] = clearBit( digits[ idx ], o );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Convert the digits to an integer value...\n\tfor ( i = 0; i < digits.length; i++ ) {\n\t\tdigits[ i ] = digits[ i ].toString();\n\t}\n\treturn parseInt( digits.join( '' ), 8 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromSymbolic;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar proc = require( 'process' );\nvar isString = require( '@stdlib/assert-is-string' ).isPrimitive;\nvar isNonNegativeInteger = require( '@stdlib/assert-is-nonnegative-integer' ).isPrimitive;\nvar isBoolean = require( '@stdlib/assert-is-boolean' ).isPrimitive;\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar format = require( '@stdlib/string-format' );\nvar toSymbolic = require( './to_symbolic.js' );\nvar fromSymbolic = require( './from_symbolic.js' );\n\n\n// MAIN //\n\n/**\n* Get/set the process mask.\n*\n* ## Notes\n*\n* -   If provided a mask, the function sets the current mask and returns the previous process mask. Otherwise, the function returns the current process mask.\n*\n*\n* @param {(NonNegativeInteger|string)} [mask] - mask\n* @param {Object} [options] - options\n* @param {boolean} [options.symbolic] - boolean indicating whether to return a mask using symbolic notation\n* @throws {TypeError} must provide either a string, nonnegative integer, or an options object\n* @throws {TypeError} must provide valid options\n* @throws {Error} must provide a parseable expression mask\n* @returns {(NonNegativeInteger|string)} process mask\n*\n* @example\n* var mask = umask();\n* // returns <number>\n*/\nfunction umask() {\n\tvar options;\n\tvar nargs;\n\tvar mask;\n\tvar opts;\n\tvar arg;\n\n\tnargs = arguments.length;\n\tif ( nargs === 0 ) {\n\t\treturn proc.umask();\n\t}\n\topts = {};\n\targ = arguments[ 0 ];\n\tif ( nargs === 1 ) {\n\t\tif ( isString( arg ) ) {\n\t\t\tmask = fromSymbolic( proc.umask(), arg );\n\t\t\tif ( mask instanceof Error ) {\n\t\t\t\tthrow mask;\n\t\t\t}\n\t\t\treturn proc.umask( mask );\n\t\t}\n\t\tif ( isNonNegativeInteger( arg ) ) {\n\t\t\t// Easy case where we use the built-in function to set the mask and return its return value:\n\t\t\treturn proc.umask( arg );\n\t\t}\n\t\tif ( isObject( arg ) ) {\n\t\t\tif ( hasOwnProp( arg, 'symbolic' ) ) {\n\t\t\t\topts.symbolic = arg.symbolic;\n\t\t\t\tif ( !isBoolean( opts.symbolic ) ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'symbolic', opts.symbolic ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask = proc.umask();\n\t\t\tif ( opts.symbolic ) {\n\t\t\t\tmask = toSymbolic( mask );\n\t\t\t}\n\t\t\treturn mask;\n\t\t}\n\t\tthrow new TypeError( format( 'invalid argument. Must provide either a string, nonnegative integer, or an options object. Value: `%s`.', arg ) );\n\t}\n\toptions = arguments[ 1 ];\n\tif ( !isObject( options ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t}\n\tif ( hasOwnProp( options, 'symbolic' ) ) {\n\t\topts.symbolic = options.symbolic;\n\t\tif ( !isBoolean( opts.symbolic ) ) {\n\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'symbolic', opts.symbolic ) );\n\t\t}\n\t}\n\tif ( isString( arg ) ) {\n\t\tmask = fromSymbolic( proc.umask(), arg );\n\t\tif ( mask instanceof Error ) {\n\t\t\tthrow mask;\n\t\t}\n\t} else if ( isNonNegativeInteger( arg ) ) {\n\t\tmask = arg;\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be either a string or nonnegative integer. Value: `%s`.', arg ) );\n\t}\n\t// Set the mask:\n\tmask = proc.umask( mask );\n\n\t// Determine how to format the output value:\n\tif ( opts.symbolic ) {\n\t\tmask = toSymbolic( mask );\n\t}\n\treturn mask;\n}\n\n\n// EXPORTS //\n\nmodule.exports = umask;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Get/set the process mask.\n*\n* @module @stdlib/process-umask\n*\n* @example\n* var umask = require( '@stdlib/process-umask' );\n*\n* var mask = umask();\n* // returns <number>\n*/\n\n// MODULES //\n\nvar umask = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = umask;\n"],"names":["lpad","require$$0","OCTAL_CODES","to_symbolic","mask","out","toString","format","require$$1","RE_MASK_EXPRESSION","PERMS","r","w","x","WHO","s","u","g","o","bitMask","offset","clearBit","value","from_symbolic","expr","digits","parts","perm","who","tmp","idx","op","i","j","k","split","length","parseInt","match","Error","join","proc","isString","isPrimitive","isNonNegativeInteger","require$$2","isBoolean","require$$3","isObject","require$$4","hasOwnProp","require$$5","require$$6","toSymbolic","require$$7","fromSymbolic","require$$8","lib","options","nargs","opts","arg","arguments","umask","symbolic","TypeError"],"mappings":"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"}